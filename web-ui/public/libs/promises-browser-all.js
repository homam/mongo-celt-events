require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
// Generated by LiveScript 1.2.0
(function(){
  var Promise, inherit, Obj, LazyPromise, i$, ref$, len$, k;
  require('setimmediate');
  Promise = require('promise');
  inherit = require('inherits');
  Obj = require('prelude-ls').Obj;
  LazyPromise = function(fn){
    var promise;
    if (!this instanceof LazyPromise) {
      return new LazyPromise(fn);
    }
    if (typeof fn !== 'function') {
      throw new TypeError('Promise constructor takes a function argument');
    }
    promise = null;
    this.then = function(res, rej){
      if (promise === null) {
        promise = new Promise(function(res_, rej_){
          setImmediate(function(){
            fn(res_, rej_);
          });
        });
      }
      return promise.then(res, rej);
    };
    this['catch'] = function(rej){
      if (promise === null) {
        promise = new Promise(function(res_, rej_){
          setImmediate(function(){
            fn(res_, rej_);
          });
        });
      }
      return promise['catch'](rej);
    };
  };
  for (i$ = 0, len$ = (ref$ = Obj.keys(Promise)).length; i$ < len$; ++i$) {
    k = ref$[i$];
    LazyPromise[k] = Promise[k];
  }
  module.exports = LazyPromise;
  inherit(LazyPromise, Promise);
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":6,"prelude-ls":12,"promise":14,"setimmediate":16}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, map, zip, empty, flip, fold, foldr, filter, concat, groupBy, div, objToPairs, last, sortBy, find, flatten, monadize, kcompM, joinM, filterM, foldM, sequenceM, mapM, liftM, liftM2, ap, listMonad, pureEither, fmapEither, bindEither, eitherMonad, pureWriter, fmapWriter, bindWriter, tellWriter, writerMonad, makeWriterMonad, listWriterMonad, memorizeMonad, exports, slice$ = [].slice;
  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, zip = ref$.zip, empty = ref$.empty, flip = ref$.flip, fold = ref$.fold, foldr = ref$.foldr, filter = ref$.filter, concat = ref$.concat, groupBy = ref$.groupBy, div = ref$.div, objToPairs = ref$.objToPairs, last = ref$.last, sortBy = ref$.sortBy, find = ref$.find, flatten = ref$.flatten;
  monadize = function(pure, fmap, bind){
    return {
      pure: pure,
      fmap: fmap,
      bind: bind,
      ffmap: flip(fmap),
      fbind: flip(bind),
      '<$>': fmap,
      '>>=': bind,
      '=<<': flip(bind),
      '>=>': curry$(function(f, g){
        return kcompM(this, f, g);
      }),
      '<=<': curry$(function(f, g){
        return kcompM(this, g, f);
      })
    };
  };
  kcompM = curry$(function(monad, f, g){
    return function(x){
      return monad.bind(f(x), g);
    };
  });
  joinM = curry$(function(monad, mx){
    return monad.bind(mx, id);
  });
  filterM = curry$(function(monad, f, list){
    var x, xs;
    x = list[0], xs = slice$.call(list, 1);
    if (empty(list)) {
      return monad.pure([]);
    }
    return monad.fbind(function(fx){
      return monad.fbind(function(ys){
        return monad.pure(fx ? [x].concat(ys) : ys);
      })(
      filterM(monad, f, xs));
    })(
    f(x));
  });
  foldM = curry$(function(monad, f, a, list){
    var x, xs;
    x = list[0], xs = slice$.call(list, 1);
    switch (false) {
    case !empty(list):
      return monad.pure(a);
    default:
      return monad.bind(f(a, x), function(fax){
        return foldM(monad, f, fax, xs);
      });
    }
  });
  sequenceM = curry$(function(monad, mxs){
    var k;
    k = curry$(function(m, mp){
      return monad.fbind(function(x){
        return monad.fbind(function(xs){
          return monad.pure([x].concat(xs));
        })(
        mp);
      })(
      m);
    });
    return foldr(k, monad.pure([]), mxs);
  });
  mapM = curry$(function(monad, f, xs){
    return sequenceM(monad, map(f, xs));
  });
  liftM = function(monad, f, mx){
    return monad.fbind(function(x){
      return monad.pure(f(x));
    })(
    mx);
  };
  liftM2 = curry$(function(monad, f, m1, m2){
    return monad.fbind(function(x1){
      return monad.fbind(function(x2){
        return monad.pure(f(x1, x2));
      })(
      m2);
    })(
    m1);
  });
  ap = function(monad){
    return liftM2(monad, id);
  };
  listMonad = monadize(function(it){
    return [it];
  }, map, flip(function(){
    return concat(map.apply(this, arguments));
  }));
  pureEither = function(x){
    return [null, x];
  };
  fmapEither = curry$(function(f, arg$){
    var err, x;
    err = arg$[0], x = arg$[1];
    if (!!err) {
      return [err, null];
    } else {
      return [null, f(x)];
    }
  });
  bindEither = curry$(function(arg$, g){
    var errf, fx;
    errf = arg$[0], fx = arg$[1];
    if (!!errf) {
      return [errf, null];
    } else {
      return g(fx);
    }
  });
  eitherMonad = (ref$ = monadize(pureEither, fmapEither, bindEither), ref$.error = function(e){
    return [e, null];
  }, ref$);
  pureWriter = curry$(function(mempty, x){
    return [x, mempty];
  });
  fmapWriter = curry$(function(f, arg$){
    var x, s;
    x = arg$[0], s = arg$[1];
    return [f(x), s];
  });
  bindWriter = curry$(function(mappend, arg$, f){
    var x, xs, ref$, y, ys;
    x = arg$[0], xs = arg$[1];
    ref$ = f(x), y = ref$[0], ys = ref$[1];
    return [y, mappend(xs, ys)];
  });
  tellWriter = curry$(function(mappend, arg$, s){
    var x, xs;
    x = arg$[0], xs = arg$[1];
    return [x, mappend(xs, s)];
  });
  writerMonad = (ref$ = monadize(pureWriter, fmapWriter, bindWriter), ref$.tell = tellWriter, ref$);
  makeWriterMonad = function(mempty, mappend){
    var ref$;
    return ref$ = monadize(pureWriter(mempty), fmapWriter, bindWriter(mappend)), ref$.tell = tellWriter(mappend), ref$;
  };
  listWriterMonad = makeWriterMonad([], curry$(function(x$, y$){
    return x$.concat(y$);
  }));
  memorizeMonad = monadize(function(x){
    return [x, x];
  }, curry$(function(f, arg$){
    var x, s;
    x = arg$[0], s = arg$[1];
    return [f(x), s];
  }), curry$(function(arg$, f){
    var x, s, ref$, y, _;
    x = arg$[0], s = arg$[1];
    ref$ = f(x), y = ref$[0], _ = ref$[1];
    return [y, s];
  }));
  exports = exports || this;
  exports.monadize = monadize;
  exports.filterM = filterM;
  exports.foldM = foldM;
  exports.sequenceM = sequenceM;
  exports.mapM = mapM;
  exports.joinM = joinM;
  exports.liftM = liftM;
  exports.liftM2 = liftM2;
  exports.ap = ap;
  exports.listMonad = listMonad;
  exports.eitherMonad = eitherMonad;
  exports.writerMonad = writerMonad;
  exports.makeWriterMonad = makeWriterMonad;
  exports.listWriterMonad = listWriterMonad;
  exports.memorizeMonad = memorizeMonad;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

},{"prelude-ls":12}],"6sSbrQ":[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, map, zip, empty, flip, foldr, filter, concat, groupBy, div, objToPairs, last, sortBy, find, flatten, Promise, monadize, filterM, foldM, sequenceM, returnP, fmapP, ffmapP, bindP, fbindP, promiseMonad, filterP, foldP, sequenceP, partitionInNParts, limit, parallelMap, serialMap, parallelLimitedMap, parallelFilter, serialFilter, parallelLimitedFilter, mplusPromiseBooleanObject, msumPromiseBooleanObject, parallelFindAny, serialFindAny, parallelAny, serialAny, parallelLimitedAny, parallelAll, serialAll, parallelLimitedAll, parallelFind, serialFind, parallelLimitedFind, parallelSequence, serialSequence, parallelLimitedSequence, parallelApplyEach, serialApplyEach, parallelLimitedApplyEach, parallelSortBy, subsetsOfSize, parallelSortWith, waterfall, transformPromiseEither, ftransformPromiseEither, transformEitherPromise, ftransformEitherPromise, leftOrRight, toCallback, fromValueCallback, fromErrorOnlyCallback, fromVoidCallback, fromErrorValueCallback, fromErrorValuesCallback, fromNamedCallbacks, newPromise, exports, slice$ = [].slice;
  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, zip = ref$.zip, empty = ref$.empty, flip = ref$.flip, foldr = ref$.foldr, filter = ref$.filter, concat = ref$.concat, groupBy = ref$.groupBy, div = ref$.div, objToPairs = ref$.objToPairs, last = ref$.last, sortBy = ref$.sortBy, find = ref$.find, flatten = ref$.flatten;
  Promise = require('./lazypromise');
  ref$ = require('./monads'), monadize = ref$.monadize, filterM = ref$.filterM, foldM = ref$.foldM, sequenceM = ref$.sequenceM;
  returnP = function(x){
    return Promise.resolve(x);
  };
  fmapP = curry$(function(f, g){
    return g.then(function(it){
      return f(it);
    });
  });
  ffmapP = flip(fmapP);
  bindP = curry$(function(f, g){
    return f.then(function(fx){
      return g(fx);
    });
  });
  fbindP = flip(bindP);
  promiseMonad = monadize(returnP, fmapP, bindP);
  filterP = filterM(promiseMonad);
  foldP = foldM(promiseMonad);
  sequenceP = sequenceM(promiseMonad);
  partitionInNParts = curry$(function(n, arr){
    return map(function(){
      return map(function(it){
        return it[0];
      })(function(it){
        return it[1];
      }.apply(this, arguments));
    })(
    objToPairs(
    groupBy(function(arg$){
      var _, i;
      _ = arg$[0], i = arg$[1];
      return div(i, n);
    })(
    zip(arr, (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = arr.length - 1; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }())))));
  });
  limit = curry$(function(serial, parallel, projection, n, f, xs){
    var parts;
    parts = partitionInNParts(n, xs);
    return ffmapP(bindP(returnP(parts), serial(parallel(f))), projection);
  });
  parallelMap = curry$(function(f, xs){
    return Promise.all(map(f, xs));
  });
  serialMap = curry$(function(f, list){
    var x, xs;
    x = list[0], xs = slice$.call(list, 1);
    if (empty(list)) {
      return returnP([]);
    }
    return fbindP(function(fx){
      return fbindP(function(fxs){
        return returnP([fx].concat(fxs));
      })(
      serialMap(f, xs));
    })(
    f(x));
  });
  parallelLimitedMap = limit(serialMap, parallelMap, concat);
  parallelFilter = curry$(function(f, xs){
    var g;
    g = function(x){
      return ffmapP(f(x), function(fx){
        return [fx, x];
      });
    };
    return fmapP(function(){
      return map(function(it){
        return it[1];
      })(filter(function(it){
        return it[0];
      }).apply(this, arguments));
    })(
    parallelMap(g, xs));
  });
  serialFilter = filterP;
  parallelLimitedFilter = limit(serialMap, parallelFilter, concat);
  mplusPromiseBooleanObject = curry$(function(pa, pb){
    return fbindP(function(arg$){
      var b, o;
      b = arg$[0], o = arg$[1];
      switch (false) {
      case !b:
        return pa;
      default:
        return pb;
      }
    })(
    pa);
  });
  msumPromiseBooleanObject = function(mxs){
    return foldr(mplusPromiseBooleanObject, returnP([false, null]), mxs);
  };
  parallelFindAny = curry$(function(f, xs){
    return msumPromiseBooleanObject(
    map(function(x){
      return ffmapP(f(x), function(b){
        return [b, x];
      });
    }, xs));
  });
  serialFindAny = curry$(function(selector, f, list){
    var x, xs;
    x = list[0], xs = slice$.call(list, 1);
    if (empty(list)) {
      return returnP([false, null]);
    }
    return fbindP(function(arg$){
      var b, x;
      b = arg$[0], x = arg$[1];
      switch (false) {
      case !b:
        return returnP([b, x]);
      default:
        return serialFindAny(selector, f, xs);
      }
    })(
    fmapP(selector(x))(
    f(x)));
  });
  parallelAny = curry$(function(f, xs){
    return ffmapP(parallelFindAny(f, xs), function(it){
      return it[0];
    });
  });
  serialAny = curry$(function(f, xs){
    return ffmapP(serialFindAny(curry$(function(_, b){
      return [b, _];
    }), f, xs), function(it){
      return it[0];
    });
  });
  parallelLimitedAny = limit(serialAny, parallelAny, id);
  parallelAll = curry$(function(f, xs){
    return ffmapP(parallelFindAny(function(x){
      return ffmapP(f(x), not$);
    }, xs), function(){
      return not$(function(it){
        return it[0];
      }.apply(this, arguments));
    });
  });
  serialAll = curry$(function(f, xs){
    return ffmapP(serialFindAny(curry$(function(_, b){
      return [b, _];
    }), function(x){
      return ffmapP(f(x), not$);
    }, xs), function(){
      return not$(function(it){
        return it[0];
      }.apply(this, arguments));
    });
  });
  parallelLimitedAll = limit(serialAll, parallelAll, id);
  parallelFind = curry$(function(f, xs){
    return ffmapP(parallelFindAny(f, xs), function(it){
      return it[1];
    });
  });
  serialFind = curry$(function(f, xs){
    return ffmapP(serialFindAny(curry$(function(x, arg$){
      var b, y;
      b = arg$[0], y = arg$[1];
      return [b, y];
    }), function(x){
      return ffmapP(f(x), function(fx){
        return [fx, x];
      });
    }, xs), function(it){
      return it[1];
    });
  });
  parallelLimitedFind = limit(serialFindAny(curry$(function(x, arg$){
    var b, y;
    b = arg$[0], y = arg$[1];
    return [b, y];
  })), parallelFindAny, function(it){
    return it[1];
  });
  parallelSequence = sequenceP;
  serialSequence = function(list){
    return foldP(function(a, x){
      return ffmapP(x, function(it){
        return a.concat([it]);
      });
    }, [], list);
  };
  parallelLimitedSequence = curry$(function(n, xs){
    var parts;
    parts = partitionInNParts(n, xs);
    return ffmapP(bindP(returnP(parts), serialMap(sequenceP)), concat);
  });
  parallelApplyEach = curry$(function(x, fs){
    return parallelSequence(map((function(it){
      return it(x);
    }), fs));
  });
  serialApplyEach = curry$(function(x, fs){
    return serialSequence(map((function(it){
      return it(x);
    }), fs));
  });
  parallelLimitedApplyEach = limit(serialMap, parallelApplyEach, concat);
  parallelSortBy = curry$(function(f, xs){
    var g;
    g = function(x){
      return ffmapP(bindP(returnP(x), f), function(fx){
        return [fx, x];
      });
    };
    return fmapP(function(){
      return map(function(it){
        return it[1];
      })(sortBy(function(it){
        return it[0];
      }).apply(this, arguments));
    })(
    fbindP(parallelMap(g))(
    returnP(xs)));
  });
  subsetsOfSize = function(set, k){
    var x, xs;
    x = set[0], xs = slice$.call(set, 1);
    switch (false) {
    case k !== 0:
      return [[]];
    case !empty(set):
      return [];
    default:
      return map((function(it){
        return [x].concat(it);
      }), subsetsOfSize(xs, k - 1)).concat(subsetsOfSize(xs, k));
    }
  };
  parallelSortWith = curry$(function(f, xs){
    var compareP, ilist;
    compareP = function(arg$){
      var ref$, a, ia, b, ib;
      ref$ = arg$[0], a = ref$[0], ia = ref$[1], ref$ = arg$[1], b = ref$[0], ib = ref$[1];
      return fbindP(function(c){
        return [ia, ib, c];
      })(
      f(a, b));
    };
    ilist = zip(xs, (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = xs.length - 1; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
    return fmapP(function(cs){
      var compare;
      compare = function(arg$, arg1$){
        var a, ia, b, ib, direction, tuple, _, c;
        a = arg$[0], ia = arg$[1];
        b = arg1$[0], ib = arg1$[1];
        direction = ia > ib;
        if ((tuple = find(function(arg$){
          var x, y, _;
          x = arg$[0], y = arg$[1], _ = arg$[2];
          switch (false) {
          case !direction:
            return y === ia && x === ib;
          default:
            return x === ia && y === ib;
          }
        }, cs)) != null) {
          _ = tuple[0], _ = tuple[1], c = tuple[2];
        }
        if (direction) {
          return -1 * c;
        } else {
          return c;
        }
      };
      return ilist.concat().sort(compare).map(function(it){
        return it[0];
      });
    })(
    fbindP(parallelMap(compareP))(
    returnP(subsetsOfSize(ilist, 2))));
  });
  waterfall = curry$(function(x, fs){
    return foldP(function(a, y){
      return y(a);
    }, x, fs);
  });
  transformPromiseEither = curry$(function(f, g){
    return newPromise(function(res, rej){
      f.then(function(fx){
        var ref$, errg, gfx;
        ref$ = g(fx), errg = ref$[0], gfx = ref$[1];
        if (!!errg) {
          return rej(new Error(errg));
        } else {
          return res(gfx);
        }
      });
      return f['catch'](function(err){
        return rej(err);
      });
    });
  });
  ftransformPromiseEither = flip(transformPromiseEither);
  transformEitherPromise = function(arg$, g){
    var errf, fx;
    errf = arg$[0], fx = arg$[1];
    return newPromise(function(res, rej){
      if (!!errf) {
        return rej(new Error(errf));
      } else {
        return res(g(fx));
      }
    });
  };
  ftransformEitherPromise = flip(transformEitherPromise);
  leftOrRight = curry$(function(f, g, x){
    return newPromise(function(res, rej){
      var x$;
      x$ = f(x);
      x$.then(function(it){
        return res(it);
      });
      x$['catch'](function(){
        return g(x).then(res, rej);
      });
      return x$;
    });
  });
  toCallback = curry$(function(p, callback){
    p.then(function(it){
      return callback(null, it);
    });
    p['catch'](function(it){
      return callback(it, null);
    });
  });
  fromValueCallback = function(f){
    return function(){
      var args, _res;
      args = slice$.call(arguments);
      _res = null;
      args = args.concat([function(it){
        return _res(it);
      }]);
      return newPromise(function(res, rej){
        var ex;
        _res = res;
        try {
          return f.apply(null, args);
        } catch (e$) {
          ex = e$;
          return rej(ex);
        }
      });
    };
  };
  fromErrorOnlyCallback = function(f, self){
    self == null && (self = null);
    return function(){
      var args;
      args = slice$.call(arguments);
      return newPromise(function(res, rej){
        var args;
        args = (args || []).concat([function(err){
          if (!!err) {
            return rej(err);
          }
          return res();
        }]);
        return f.apply(self, args);
      });
    };
  };
  fromVoidCallback = function(f){
    return function(){
      var args, _res;
      args = slice$.call(arguments);
      _res = null;
      args = args.concat([function(){
        return _res();
      }]);
      return newPromise(function(res, rej){
        var ex;
        _res = res;
        try {
          return f.apply(null, args);
        } catch (e$) {
          ex = e$;
          return rej(ex);
        }
      });
    };
  };
  fromErrorValueCallback = function(f, self){
    self == null && (self = null);
    return function(){
      var args, _res, _rej;
      args = slice$.call(arguments);
      _res = null;
      _rej = null;
      args = args.concat([function(error, result){
        if (!!error) {
          return _rej(error);
        }
        return _res(result);
      }]);
      return newPromise(function(res, rej){
        var ex;
        _res = res;
        _rej = rej;
        try {
          return f.apply(self, args);
        } catch (e$) {
          ex = e$;
          return rej(ex);
        }
      });
    };
  };
  fromErrorValuesCallback = function(projection, f){
    return function(){
      var args, _res, _rej;
      args = slice$.call(arguments);
      _res = null;
      _rej = null;
      args = args.concat([function(error){
        var more;
        more = slice$.call(arguments, 1);
        if (!!error) {
          return _rej(error);
        }
        return _res(projection.apply(null, more));
      }]);
      return newPromise(function(res, rej){
        var ex;
        _res = res;
        _rej = rej;
        try {
          return f.apply(null, args);
        } catch (e$) {
          ex = e$;
          return rej(ex);
        }
      });
    };
  };
  fromNamedCallbacks = function(successName, errorName, obj){
    var _res, _rej;
    _res = null;
    _rej = null;
    obj[successName] = function(it){
      return _res(it);
    };
    obj[errorName] = function(it){
      return _rej(it);
    };
    return newPromise(function(res, rej){
      _res = res;
      return _rej = rej;
    });
  };
  newPromise = function(callback){
    return new Promise(function(res, rej){
      return callback(res, rej);
    });
  };
  exports = exports || this;
  exports.LazyPromise = Promise;
  exports.newPromise = newPromise;
  exports.returnP = returnP;
  exports.fmapP = fmapP;
  exports.ffmapP = ffmapP;
  exports.bindP = bindP;
  exports.fbindP = fbindP;
  exports.foldP = foldP;
  exports.filterP = filterP;
  exports.sequenceP = sequenceP;
  exports.promiseMonad = promiseMonad;
  exports.parallelSequence = parallelSequence;
  exports.serialSequence = serialSequence;
  exports.parallelLimitedSequence = parallelLimitedSequence;
  exports.serialFilter = serialFilter;
  exports.parallelFilter = parallelFilter;
  exports.parallelLimitedFilter = parallelLimitedFilter;
  exports.serialMap = serialMap;
  exports.parallelMap = parallelMap;
  exports.parallelLimitedMap = parallelLimitedMap;
  exports.parallelAny = parallelAny;
  exports.serialAny = serialAny;
  exports.parallelLimitedAny = parallelLimitedAny;
  exports.parallelAll = parallelAll;
  exports.serialAll = serialAll;
  exports.parallelLimitedAll = parallelLimitedAll;
  exports.parallelFind = parallelFind;
  exports.serialFind = serialFind;
  exports.parallelLimitedFind = parallelLimitedFind;
  exports.parallelSortBy = parallelSortBy;
  exports.parallelSortWith = parallelSortWith;
  exports.parallelApplyEach = parallelApplyEach;
  exports.serialApplyEach = serialApplyEach;
  exports.parallelLimitedApplyEach = parallelLimitedApplyEach;
  exports.waterfall = waterfall;
  exports.transformEitherPromise = transformEitherPromise;
  exports.ftransformEitherPromise = ftransformEitherPromise;
  exports.transformPromiseEither = transformPromiseEither;
  exports.ftransformPromiseEither = ftransformPromiseEither;
  exports.leftOrRight = leftOrRight;
  exports.toCallback = toCallback;
  exports.fromValueCallback = fromValueCallback;
  exports.fromErrorOnlyCallback = fromErrorOnlyCallback;
  exports.fromVoidCallback = fromVoidCallback;
  exports.fromErrorValueCallback = fromErrorValueCallback;
  exports.fromErrorValuesCallback = fromErrorValuesCallback;
  exports.fromNamedCallbacks = fromNamedCallbacks;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function not$(x){ return !x; }
}).call(this);

},{"./lazypromise":1,"./monads":2,"prelude-ls":12}],"promises-ls":[function(require,module,exports){
module.exports=require('6sSbrQ');
},{}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],7:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var apply, curry, flip, fix, over;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],8:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
};
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
};
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(function(){
    return not$(p.apply(this, arguments));
  }, xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function not$(x){ return !x; }
},{}],9:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],10:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(objectect){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in objectect) {
    value = objectect[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
};
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],11:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],12:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.0';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"./Func.js":7,"./List.js":8,"./Num.js":9,"./Obj.js":10,"./Str.js":11}],13:[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new Promise(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":15}],14:[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions to the core promise API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Object.create(Promise.prototype)

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.from = Promise.cast = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}
Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      fn.apply(self, args)
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    try {
      return fn.apply(this, arguments).nodeify(callback)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback(ex)
        })
      }
    }
  }
}

Promise.all = function () {
  var args = Array.prototype.slice.call(arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : arguments)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

/* Prototype Methods */

Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}

Promise.prototype.nodeify = function (callback) {
  if (callback === null || typeof callback == 'undefined') return this

  this.then(function (value) {
    asap(function () {
      callback(null, value)
    })
  }, function (err) {
    asap(function () {
      callback(err)
    })
  })
}

Promise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected);
}


Promise.resolve = function (value) {
  return new Promise(function (resolve) { 
    resolve(value);
  });
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.map(function(value){
      Promise.cast(value).then(resolve, reject);
    })
  });
}

},{"./core.js":13,"asap":15}],15:[function(require,module,exports){
(function (process){

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}).call(this,require("/Users/homam/dev/async-ls/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/homam/dev/async-ls/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":5}],16:[function(require,module,exports){
(function (process,global){
(function (global, undefined) {
    "use strict";

    var tasks = (function () {
        function Task(handler, args) {
            this.handler = handler;
            this.args = args;
        }
        Task.prototype.run = function () {
            // See steps in section 5 of the spec.
            if (typeof this.handler === "function") {
                // Choice of `thisArg` is not in the setImmediate spec; `undefined` is in the setTimeout spec though:
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html
                this.handler.apply(undefined, this.args);
            } else {
                var scriptSource = "" + this.handler;
                /*jshint evil: true */
                eval(scriptSource);
            }
        };

        var nextHandle = 1; // Spec says greater than zero
        var tasksByHandle = {};
        var currentlyRunningATask = false;

        return {
            addFromSetImmediateArguments: function (args) {
                var handler = args[0];
                var argsToHandle = Array.prototype.slice.call(args, 1);
                var task = new Task(handler, argsToHandle);

                var thisHandle = nextHandle++;
                tasksByHandle[thisHandle] = task;
                return thisHandle;
            },
            runIfPresent: function (handle) {
                // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                // So if we're currently running a task, we'll need to delay this invocation.
                if (!currentlyRunningATask) {
                    var task = tasksByHandle[handle];
                    if (task) {
                        currentlyRunningATask = true;
                        try {
                            task.run();
                        } finally {
                            delete tasksByHandle[handle];
                            currentlyRunningATask = false;
                        }
                    }
                } else {
                    // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                    // "too much recursion" error.
                    global.setTimeout(function () {
                        tasks.runIfPresent(handle);
                    }, 0);
                }
            },
            remove: function (handle) {
                delete tasksByHandle[handle];
            }
        };
    }());

    function canUseNextTick() {
        // Don't get fooled by e.g. browserify environments.
        return typeof process === "object" &&
               Object.prototype.toString.call(process) === "[object process]";
    }

    function canUseMessageChannel() {
        return !!global.MessageChannel;
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.

        if (!global.postMessage || global.importScripts) {
            return false;
        }

        var postMessageIsAsynchronous = true;
        var oldOnMessage = global.onmessage;
        global.onmessage = function () {
            postMessageIsAsynchronous = false;
        };
        global.postMessage("", "*");
        global.onmessage = oldOnMessage;

        return postMessageIsAsynchronous;
    }

    function canUseReadyStateChange() {
        return "document" in global && "onreadystatechange" in global.document.createElement("script");
    }

    function installNextTickImplementation(attachTo) {
        attachTo.setImmediate = function () {
            var handle = tasks.addFromSetImmediateArguments(arguments);

            process.nextTick(function () {
                tasks.runIfPresent(handle);
            });

            return handle;
        };
    }

    function installMessageChannelImplementation(attachTo) {
        var channel = new global.MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            tasks.runIfPresent(handle);
        };
        attachTo.setImmediate = function () {
            var handle = tasks.addFromSetImmediateArguments(arguments);

            channel.port2.postMessage(handle);

            return handle;
        };
    }

    function installPostMessageImplementation(attachTo) {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var MESSAGE_PREFIX = "com.bn.NobleJS.setImmediate" + Math.random();

        function isStringAndStartsWith(string, putativeStart) {
            return typeof string === "string" && string.substring(0, putativeStart.length) === putativeStart;
        }

        function onGlobalMessage(event) {
            // This will catch all incoming messages (even from other windows!), so we need to try reasonably hard to
            // avoid letting anyone else trick us into firing off. We test the origin is still this window, and that a
            // (randomly generated) unpredictable identifying prefix is present.
            if (event.source === global && isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {
                var handle = event.data.substring(MESSAGE_PREFIX.length);
                tasks.runIfPresent(handle);
            }
        }
        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        attachTo.setImmediate = function () {
            var handle = tasks.addFromSetImmediateArguments(arguments);

            // Make `global` post a message to itself with the handle and identifying prefix, thus asynchronously
            // invoking our onGlobalMessage listener above.
            global.postMessage(MESSAGE_PREFIX + handle, "*");

            return handle;
        };
    }

    function installReadyStateChangeImplementation(attachTo) {
        attachTo.setImmediate = function () {
            var handle = tasks.addFromSetImmediateArguments(arguments);

            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var scriptEl = global.document.createElement("script");
            scriptEl.onreadystatechange = function () {
                tasks.runIfPresent(handle);

                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
            };
            global.document.documentElement.appendChild(scriptEl);

            return handle;
        };
    }

    function installSetTimeoutImplementation(attachTo) {
        attachTo.setImmediate = function () {
            var handle = tasks.addFromSetImmediateArguments(arguments);

            global.setTimeout(function () {
                tasks.runIfPresent(handle);
            }, 0);

            return handle;
        };
    }

    if (!global.setImmediate) {
        // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
        var attachTo = typeof Object.getPrototypeOf === "function" && "setTimeout" in Object.getPrototypeOf(global) ?
                          Object.getPrototypeOf(global)
                        : global;

        if (canUseNextTick()) {
            // For Node.js before 0.9
            installNextTickImplementation(attachTo);
        } else if (canUsePostMessage()) {
            // For non-IE10 modern browsers
            installPostMessageImplementation(attachTo);
        } else if (canUseMessageChannel()) {
            // For web workers, where supported
            installMessageChannelImplementation(attachTo);
        } else if (canUseReadyStateChange()) {
            // For IE 68
            installReadyStateChangeImplementation(attachTo);
        } else {
            // For older browsers
            installSetTimeoutImplementation(attachTo);
        }

        attachTo.clearImmediate = tasks.remove;
    }
}(typeof global === "object" && global ? global : this));

}).call(this,require("/Users/homam/dev/async-ls/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/Users/homam/dev/async-ls/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":5}]},{},[])